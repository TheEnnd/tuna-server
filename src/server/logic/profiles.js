const 
    fs = require('fs-extra'),
    path = require('path'),
    randomstring = require('randomstring'),
    settings = require(_$+'helpers/settings'),
    logger = require('winston-wrapper').instance(settings.logPath),
    dataCache = require(_$+'cache/profile'),
    Profile = require(_$+'types/profile'),
    sendgrid = require(_$+'helpers/sendgrid'),
    Exception = require(_$+'types/exception'),
    constants = require(_$+'types/constants')

let songsLogic, authTokenLogic;

module.exports = {
    
    authTokenLogic,

    songsLogic,

    /**
     * Autogenerates the single master user
     */
    async autoCreateMaster(username){

        let profile = await this.getByIdentifier(username)
        if (profile)
            return

        // create and write autogenerated password to file
        let 
            password = randomstring.generate(12),
            passwordFilePath = path.join(settings.dataFolder, settings.autogeneratedPasswordFile)

        await fs.outputFile(passwordFilePath, password)
        // read password back to make sure it exists on file, don't want to lock user out
        password = await fs.readFile(passwordFilePath)

        profile = Profile.new()
        profile.identifier = username
        profile.password = password
        profile.created = new Date().getTime()
        profile.isPasswordChangeForced = true
        
        this._processPassword(profile)

        profile = await dataCache.create(profile)
        
        logger.info.info('master user generated')

        return profile
    },

    
    async getAll(){
        return await dataCache.getAll()
    },


    /**
     * 
     */
    async getByIdentifier(identifier){
        return await dataCache.getByIdentifier(identifier)
    },


    /**
     * Writes an object's propeties onto an existing profile 
     */
    async updateProperties(properties){
        if (!properties.id)
            throw 'properties must have an id'

        const profile = await this.getById(properties.id)

        for (let property in profile)
            // copy over only properties that already exist in the recipient object
            if (properties[property])
                profile[property] = properties[property]

        return this.update(profile)  
    },


    /**
     *
     */
    async update(profile){
        if (!profile)
            throw new Exception({ 
                code : constants.ERROR_VALIDATION, 
                public : 'profile required' 
            })

        this._processPassword(profile)
        
        await dataCache.update(profile)
    },


    /**
     * Completely deletes a user.
     */
    async delete(profile){
        songsLogic = songsLogic || require(_$+'logic/songs')
        authTokenLogic = authTokenLogic || require(_$+'logic/authToken')

        await authTokenLogic.deleteForProfile(profile.id)

        await songsLogic.deleteAll(profile.id)

        await dataCache.delete(profile)
    },


    /**
     *
     */
    async getById(profileId){
        let profile = await dataCache.getById(profileId)
        return profile
    },


    /**
     *
     */
    requestPasswordReset : async function requestPasswordReset(identifier, email){
        
        email = email.trim()

        let profile = await dataCache.getByIdentifier(identifier)
        if (!profile)
            throw new Exception({ 
                code : constants.ERROR_VALIDATION, 
                public: 'That email address isn\'t bound to an account.'
            })

        if (!profile.email)
            throw new Exception({ 
                code : constants.ERROR_EMAIL_NOT_SET, 
                public: 'Your account doesn\t have an email address. Please reset password directly (see Tuna "help" guide for more info)'
            })

        if (profile.email.trim().toLowerCase() != email.toLowerCase())
            throw new Exception({ 
                code : constants.ERROR_EMAIL_NOT_SET, 
                public: 'The email address you gave was not found. Please reset password directly (see Tuna "help" guide for more info)'
            })

        let verificationKey = randomstring.generate(32)

        profile.passwordResetKey = verificationKey
        await dataCache.update(profile)

        let resetLink = `${settings.siteUrl}/newPassword?key=${verificationKey}`
        await sendgrid(
            profile.email, 
            'Password reset', 
            `Hi. If you forgot your password, you can click on the link below to enter a new one.\n\n ${resetLink}\n\nRegards\nSome robot`)
    },


    /**
     *
     */
    isPasswordValid (profile, password){
        const crypto = require('crypto'),
            sha512 = crypto.createHmac('sha512', profile.salt)

        sha512.update(password)

        return profile.hash = sha512.digest('hex')
    },


    /**
     * Logs user in. returns profile id of the user that was logged in
     */
    async authenticate(identifier, password){

        authTokenLogic = authTokenLogic || require(_$+'logic/authToken');

        if (!identifier)
            throw new Exception({ 
                code : constants.ERROR_VALIDATION, 
                public : 'Email required' 
            })

        if (!password)
            throw new Exception({ 
                code : constants.ERROR_VALIDATION,
                public : 'Invalid username / password ' 
            })

        // note that identifier is always trimmed and set to lowercase()
        let profile = await dataCache.getByIdentifier(identifier.trim().toLowerCase());
        if (!profile)
            throw new Exception({ 
                code : constants.ERROR_VALIDATION, 
                public : 'Invalid username / password ' 
            })

        if (!this.isPasswordValid(profile, password))
            throw new Exception({ 
                code : constants.ERROR_VALIDATION, 
                public : 'Invalid username / password' 
            });

        return profile.id;
    },


    /**
     *
     */
    async resetPassword(key, password, currentPassword, profileId){
        let profile = null,
            public

        if (key) {
            profile = await dataCache.getByPasswordResetKey(key)
            public = 'Invalid reset key'
        } else if (profileId){
            profile = await dataCache.getById(profileId)
            public = 'Invalid session'
        }

        // this shouldn't happen, as calling method enforces session
        if (!profile)
            throw new Exception({ 
                code : constants.ERROR_VALIDATION, 
                public  
            })

        // verify current password if no key, ie, already authenticated
        if (!key && !this.isPasswordValid(profile, currentPassword))
            throw new Exception({ 
                code : constants.ERROR_VALIDATION,
                public : 'Current password is invalid' 
            })

        profile.password = password
        profile.emailVerificationKey = null

        this._processPassword(profile)

        await dataCache.update(profile)

        // on password update, delete autogened password, it isn't really a security risk as it's
        // no longer valid, but let's keep things tidy
        if (await fs.pathExists(settings.autogeneratedPasswordFile))
            await fs.remove(settings.autogeneratedPasswordFile)
    },


    /**
     *
     */
    async removeLastfm(profileId){
        let profile = await dataCache.getById(profileId)
        profile.scrobbleToken = null
        await dataCache.update(profile)
    },

    async songsHashValid(profileId, hash){
        let profile = await dataCache.getById(profileId)
        if (!profile)
            throw new Exception({ code : constants.ERROR_INVALID_USER_OR_SESSION })

        const source = profile.sources[settings.musicSource]
        if (!source)
            return false

        return source.indexHash === hash
    },


    /**
     *
     */
    async removeDropbox (profileId){
        songsLogic = songsLogic || require(_$+'logic/songs')

        let profile = await dataCache.getById(profileId)
        if (!profile)
            throw new Exception({ code : constants.ERROR_INVALID_USER_OR_SESSION })

        delete profile.sources[constants.SOURCES_DROPBOX]

        await dataCache.update(profile)

        // delete all songs
        await songsLogic.deleteAll(profile.id)
    },


    /**
     * Converts a password to hash + salt on a profile object. The password is deleted in the process so it never
     * reaches the database and is thus never stored openly.
     */
    _processPassword(profile){

        if (!profile.password)
            return

        let randomstring = require('randomstring'),
            crypto = require('crypto')

        profile.salt = randomstring.generate(settings.passwordLength)

        let sha512 = crypto.createHmac('sha512', profile.salt)
        sha512.update(profile.password)
        profile.hash = sha512.digest('hex')

        // destroy password, it must not be saved to database
        delete profile.password
    }


}